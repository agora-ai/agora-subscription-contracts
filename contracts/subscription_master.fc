#include "imports/stdlib.fc";
#include "imports/op_codes/subscription_master.fc";
#include "imports/op_codes/subscription.fc";
#include "imports/errors/subscription_master.fc";
#include "imports/utils.fc";


;; Title: Agora Subscription Master
;; Author: Yuri Fernandes (0xyuri.ton)
;; Description: Deploys subscription contracts for a specific TAM (Tokenized AI Model)

;; Storage variables

;; subscription_number: Number of subscriptions
;; subscription_manager:
;;      - Change configurations of the SubscriptionMaster contract;
;;      - Request payments from Subscriptions and change minor settings in it.
;; subscription_fee: Fee to be substract by the user periodically
;; fee_period: Fee payment interval (in seconds)
;; subscription_code: Code cell of the Subscription contract to be minted by the user
global int storage::subscription_number;
global slice storage::subscription_manager;
global cell storage::subscription_code;
global int storage::subscription_fee;
global int storage::fee_period;

;; Constants
const int WORKCHAIN_ID = 0;

;; Auxiliary functions

cell assemble_subscription_data(slice owner_addr) {
    return begin_cell()
        .store_slice(my_address())
        .store_slice(owner_addr)
    .end_cell();
}

builder assemble_subscription_init_content() {
    return begin_cell()
        .store_coins(storage::subscription_fee)
        .store_uint(storage::fee_period, 32);
}

slice calculate_address_from_address(int wc, cell code, slice owner_addr) {
    var state_init = assemble_stateinit(code, assemble_subscription_data(owner_addr));
    return calculate_address_from_stateinit(wc, state_init).end_cell().begin_parse();
}

;; Storage (C4) manipulation functions

() load_data() inline {
    var ds = get_data();
    storage::subscription_number = ds~load_uint(256);
    storage::subscription_manager = ds~load_msg_addr();
    storage::subscription_fee = ds~load_coins();
    storage::fee_period = ds~load_uint(32);
    storage::subscription_code = ds~load_ref();
}

() save_data() inline {
    set_data(begin_cell()
        .store_uint(storage::subscription_number, 256)
        .store_slice(storage::subscription_manager)
        .store_coins(storage::subscription_fee)
        .store_uint(storage::fee_period, 32)
        .store_ref(storage::subscription_code)
    .end_cell());
}

;; OP functions 

() subscribe(slice sender_addr, int query_id, slice msg_body_content) inline {
    ;; sender_addr workchain should be equal to WORKCHAIN_ID constant
    force_chain(WORKCHAIN_ID, sender_addr);

    ;; prepare Subscription contract stateinit
    var state_init = assemble_stateinit(
        storage::subscription_code,
        assemble_subscription_data(sender_addr)
    );
    storage::subscription_number += 1;

    var msg_body = begin_cell()
        .store_uint(op::init, 32)
        .store_uint(query_id, 64)
        .store_builder(assemble_subscription_init_content());
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_builder(calculate_address_from_stateinit(WORKCHAIN_ID, state_init))
        .store_coins(0)
        .store_uint(4 + 2, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
        .store_ref(state_init)
        .store_builder(msg_body)
    .end_cell();

    send_raw_message(msg, 64);

    save_data();
}

() configure(slice sender_addr, int query_id, slice msg_body_content) inline {
    throw_unless(error::not_admin, sender_addr == storage::subscription_manager);

    storage::subscription_fee = msg_body_content~load_coins();
    storage::fee_period = msg_body_content~load_uint(32);

    var msg_body = begin_cell()
        .store_uint(op::excesses, 32)
        .store_uint(query_id, 64);
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(sender_addr)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_builder(msg_body)
    .end_cell();
    send_raw_message(msg, 64);

    save_data();
}

;; recv_internal is the main function of the contract and is called when it receives a message from other contracts
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; receive ton transfers (simple transfer without message)
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages (just receive excedents)
        return ();
    }

    load_data(); ;; load storage variables

    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case
    slice sender_addr = cs~load_msg_addr();

    if (op == op::subscribe) {
        subscribe(sender_addr, query_id, in_msg_body);
        return ();
    }

    if (op == op::configure) {
        configure(sender_addr, query_id, in_msg_body);
        return ();
    }

    throw(error::unknown_op); ;; if the message contains an op that is not known to this contract, we throw
}

(int, slice, int, int, cell) get_subscription_master_data() method_id {
    load_data();
    return (
        storage::subscription_number,
        storage::subscription_manager,
        storage::subscription_fee,
        storage::fee_period,
        storage::subscription_code
    );
}

slice get_user_subscription(slice user_addr) method_id {
    force_chain(WORKCHAIN_ID, user_addr);
    load_data();
    return calculate_address_from_address(WORKCHAIN_ID, storage::subscription_code, user_addr);
}